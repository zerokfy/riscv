declare fpu {
    input         s1[32]
                , s2[32]
                ;
    output        result[32]
                , sub
                , nan
                , inf
                ;
    func_in       add_s(s1, s2)
                , sub(s1, s2) 
                , mul(s1, s2) 
                , div(s1, s2) 
    func_out      ans(result, sub, nan, inf)
                ;
}

struct st_float {
      sig
    , exp[8]
    , man[23]
}

module fpu {
    st_float reg          st1_s1
                        , st1_s2
                        , st2_s1
                        , st2_s2
                        , st_ans
                        ;
    wire                  unnorm_man[25]
                        , s1man_s[23]
                        , s2man_s[23]
                        ;
    wire                  s1sig
                        , s1exp[8]
                        , s1man[24]
                        , s2sig
                        , s2exp[8]
                        , s2man[24]
                        , s1sig_r2
                        , s1exp_r2[8]
                        , s1man_r2[24]
                        , s2sig_r2
                        , s2exp_r2[8]
                        , s2man_r2[24]
                        ;
    func_self             chk_except()
                        ;
    proc_name             adjust_digit()
                        , normalize(shamt)
                        ;


    func add seq {
        chk_except();
    }

    func chk_except any {
        (st_s1.exp==8'h00) && (st_s1.man!=23'h0) :  sub := 1'b1;
        (st_s1.exp==8'hFF) && (st_s1.man==23'h0) :  inf := 1'b1; 
        (st_s1.exp==8'hFF) && (st_s1.man!=23'h0) :  nan := 1'b1; 
        (st_s1.exp==8'h01)                       :  almost_sub := 1'b1; 
        (st_s1.exp==8'hFE)                       :  almost_nan := 1'b1; 
        (st_s2.exp==8'h00) && (st_s2.man!=23'h0) :  sub := 1'b1;
        (st_s2.exp==8'hFF) && (st_s2.man==23'h0) :  inf := 1'b1; 
        (st_s2.exp==8'hFF) && (st_s2.man!=23'h0) :  nan := 1'b1; 
        (st_s2.exp==8'h01)                       :  almost_sub := 1'b1; 
        (st_s2.exp==8'hFE)                       :  almost_nan := 1'b1; 
    }

    proc adjust_digit {
        s1sig = s1[31];
        s2sig = s2[31];
        any {
            s1[30:23] >= s2[30:23] : {
                s1exp = s1[30:23];
                s1man = s1[22:0];
                s2exp = s1[30:23];
                s2man = {1'b1, s2[22:0]} >> (s1[30:23]-s2[30:23]);
            }
            s1[30:23] <  s2[30:23] : {
                s1exp = s2[30:23];
                s1man = {1'b1, s2[22:0]} >> (s2[30:23]-s1[30:23]);
                s2exp = s1[30:23];
                s2man = s1[22:0];
            }   
        }
        any {
            s1sig :  s1man = ~s1man + 24'h1;
           ~s1sig :  s1man =  s1man;
            s2sig :  s2man = ~s2man + 24'h1;
           ~s2sig :  s2man =  s2man;
        }
        unnorm_man = s1man + s1man;
        normalize(5'd24);
    }

    proc normalize {
        any {
            unnorm_man[24] : {
                st_ans.man := unnorm_man[23:1];
                exp_add    := 8'h1;
            }
            unnorm_man[23] : {
                st_ans.man := unnorm_man[22:0];
                exp_add    := 8'h0;
            }
            unnorm_man[shamt] : {
                st_ans.man := unnorm_man[22:0] << shamt;
                exp_add    := 8'shamt;
            }
            normalize(shamt--);
        }
    }
}

